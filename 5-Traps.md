# Trap
## 1. Trap的解释
由CPU进程导致的中断称为陷入（trap），由外部设备导致的中断称为中断（interrupt）。

Trap通俗一点来讲，就是由用户程序触发的操作系统用户态与内核态的切换，这一点要与interrupt（中断）区分开来。中断主要是由硬件触发，是由外部事件导致的。有关中断我们会在之后的文章中进行详细介绍，现在记住它们的区别就好。

总体来说，导致用户态与内核态发生切换主要会有以下三种情况：

1. 系统调用（system call）
2. Page fault（缺页），运算时除以0的错误等
3. 一个设备触发了中断使得当前程序运行需要响应内核设备驱动

而在这几种情况中，很明显的，1和2都属于trap的范畴，而3则是一个中断的典型例子。

## 2. Trap的处理过程
### 2.1 基本方案
在开始中断处理程序之前，处理器保存寄存器，这样在操作系统从中断中返回时就可以恢复他们，切换到中断服务程序面临的问题是处理器需要在用户模式和内核模式之间切换。

trap通常的顺序是：

1. trap迫使控制权转移到内核；
2. 内核保存寄存器和其他状态，以便恢复执行；
3. 内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）；
4. 内核恢复保存的状态，并从trap中返回；
5. 代码从原来的地方恢复执行。

### 2.2 trap程序中用户态到内核态的转移过程
1. 首先，我们需要保存32个用户寄存器到栈中。因为很显然我们需要恢复用户应用程序的执行，尤其是当用户程序随机的被设备中断所打断时。我们希望内核能够响应中断，之后在用户程序完全无感知的情况下再恢复用户代码的执行。所以这意味着32个用户寄存器不能被内核弄乱。但是这些寄存器又要被内核代码所使用，所以在trap之前，你必须先在某处保存这32个用户寄存器。
  
2. 程序计数器也需要在某个地方保存，它几乎跟一个用户寄存器的地位是一样的，我们需要能够在用户程序运行中断的位置继续执行用户程序。
  
3. 进入内核状态。我们需要将mode改成supervisor mode，因为我们想要使用内核中的各种各样的特权指令。
  
4. SATP寄存器现在正指向user page table，而user page table只包含了用户程序所需要的内存映射和一两个其他的映射，它并没有包含整个内核数据的内存映射。所以在运行内核代码之前，我们需要将SATP指向kernel page table。
  
5. 我们需要将堆栈寄存器指向位于内核的一个地址，因为我们需要一个堆栈来调用内核的C函数。
  
6. 一旦我们设置好了，并且所有的硬件状态都适合在内核中使用， 我们需要跳入内核的C代码。

### 2.3 Trap代码执行流程（以write()为例）
首先要明确一点，在执行系统调用之前，我们还处在shell当中。当调用时，write会调用ECALL指令，而ECALL会切换到supervisor mode的内核中，trap在内核中的流程就开始了。

1. ecall进入内核。

2. 在内核中的第一步，是要执行一个uservec的汇编函数，而它指向的则是C语言实现的usertrap函数。到了usertrap()之后，我们会在这个函数中执行一个通用的syscall()函数。

3. 在内核中执行任务。syscall()函数会根据传入的代表相应系统调用的数字，在一个系统调用的表单中找到与这个数字对应的系统调用，也就是sys_write()。

4. 从内核中返回。sys_write()完成之后，接着返回syscall()函数，为了恢复用户空间代码的执行，syscall()会接着调用usertrapret()函数来完成返回用户空间的部分工作。

5. 返回用户态。正如进入内核态时需要先调用一个汇编函数一样，在返回的过程中，有些工作必须要由一个汇编函数来进行，所以我们又会调用userset汇编函数，它把我们带回了用户空间，并从ECALL指令开始继续往下执行。

举一个小例子，我们最常用的print()函数，本质上就是调用了底层的write()系统调用向屏幕写入字符。具体的写入则是由sys_write()保障，也就是我们上面说的第四步中的内容。在第四步执行完时，我们已经可以在屏幕上看到内容，操作系统剩下的任务就是保证安全的返回用户态。

### 2.4 32个用户寄存器的保存
XV6在每个user page table映射了trapframe page，这样每个进程都有自己的trapframe page。这个page类似于用户与内核之间的一个跳板，包含了很多有趣的数据，但是现在最重要的数据是用来保存用户寄存器的32个空槽位。所以，在trap处理代码中，我们在user page table有一个之前由kernel设置好的PTE，这个PTE指向了一个可以用来存放这个进程执行ecall前的32个用户寄存器的值的内存位置，即trapframe page。这个位置的虚拟地址总是0x3ffffffe000。

如果将内核内存映射到每个进程的用户页面表中(带有适当的PTE权限标志)，就可以不需要trapframe page，也不需要在用户到内核的过程中从用户page table切换到内核page table。

注意：trampoline代码在用户空间和内核空间都映射到了同一个地址。

