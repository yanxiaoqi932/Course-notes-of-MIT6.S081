# Thread switching
## 1. 线程（thread）的概念
### 1.1 线程的定义和特点
线程可以认为是一种在有多个任务时简化编程的抽象。线程就是单个串行执行代码的单元，它只占用一个CPU并且以普通的方式一个接一个的执行指令。

除此之外，线程还具有状态，我们可以随时保存线程的状态并暂停线程的运行，并在之后通过恢复状态来恢复线程的运行。线程的状态包含了三个部分：
- 程序计数器（Program Counter），它表示当前线程执行指令的位置。
- 保存变量的寄存器。
- 程序的Stack。通常来说每个线程都有属于自己的Stack，Stack记录了函数调用的记录，并反映了当前线程的执行点。

### 1.2 多线程并行
多线程的并行运行主要有两个策略：

- 第一个策略是在多核处理器上使用多个CPU，每个CPU都可以运行一个线程，每个线程自动地根据所在CPU就有了程序计数器和寄存器。但是如果你只有4个CPU，却有上千个线程，每个CPU只运行一个线程就不能解决这里的问题了。
- 第二个策略，也就是一个CPU在多个线程之间来回切换。假设我只有一个CPU，但是有1000个线程，操作系统通过线程切换使得cpu能够先运行一个线程，之后将线程的状态保存，再切换至运行第二个线程，然后再是第三个线程，依次类推直到每个线程都运行了一会，再回来重新执行第一个线程。

### 1.3 线程的地址空间
Linux允许在一个用户进程中包含多个线程，进程中的多个线程共享进程的地址空间。当你想要实现一个运行在多个CPU核上的用户进程时，你就可以在用户进程中创建多个线程。

多个线程都在一个地址空间内运行，并且它们可以看到彼此的更新。比如说共享一个地址空间的线程修改了一个变量，共享地址空间的另一个线程可以看到变量的修改。所以当多个线程运行在一个共享地址空间时，需要用到锁。

## 2. thread switch的概念
### 2.1 thread switch的定义
任何操作系统运行的进程数量都可能超过计算机的CPU数量，因此需要制定一个方案，在各进程之间分时共享CPU。要想实现cpu的复用，就需要进行多个进程之间的切换。

通过定时器中断可以实现将线程强制切换到另一个线程，即便旧的进程不愿意让出CPU。

### 2.2 线程的不同状态
在执行线程调度的时候，操作系统需要能区分几类线程：
- 当前在CPU上运行的线程；
- 一旦CPU有空闲时间就想要运行在CPU上的线程；
- 以及不想运行在CPU上的线程，因为这些线程可能在等待I/O或者其他事件。

这里不同的线程是由状态区分，常见的几种线程状态：
- RUNNING，线程当前正在某个CPU上运行；
- RUNABLE，线程还没有在某个CPU上运行，但是一旦有空闲的CPU就可以运行；
- SLEEPING，这个状态意味着线程在等待一些I/O事件，它只会在I/O事件发生了之后运行。

### 2.3 内核让出cpu的条件
内核会在三个场景下出让CPU：
- 定时器中断触发了，内核总是会让当前进程出让CPU；
- 一个进程调用了系统调用并等待I/O，等待I/O的机制会触发出让CPU；
- 占用cpu的进程结束运行。

## 3. context switch
![context switch](images/context_switch.png)
上图概述了从一个用户进程切换到另一个用户进程所涉及的步骤：
1. 用户-内核的切换（通过系统调用或中断）到旧进程的内核线程；
2. 线程A保存自己的上下文（内核寄存器，用户寄存器保存在trapframe中，因为内核不可以使用用户寄存器），获取进程锁p->lock，释放它所持有的其它锁，更新自己的状态（p->state）。然后切换到当前CPU的调度器线程，恢复调度器线程的上下文；
3. 调度器线程继续for循环，找到一个要运行的进程，保存调度器线程上下文。切换到进程B的内核线程B，释放进程锁p->lock（和A是同一个线程锁），恢复线程B的上下文；
4. trap返回到用户级进程。

补充：
- xv6在每个CPU上有一个专门的调度器线程(保存了寄存器和栈)，因为调度器在旧进程的内核栈上执行是不安全的，它以cpu特殊线程的形式存在。线程A上下文首先切换到调度器线程，再由调度器线程发挥调度作用，切换到线程B。<font color=#0000ff>可以看出这里没有两个用户进程之间的直接切换，只有用户进程和调度器线程之间的切换。</font>

- 一般来说获得锁的线程也要负责释放锁，这样才容易保证正确性。对于上下文切换来说，有必要打破这个约定，因为其他每一个CPU核都有一个调度器线程在遍历进程表单，如果没有在进程切换的最开始就获取进程的锁的话，其他CPU核就有可能在当前进程还在运行时，认为该进程是RUNNABLE并运行它。而两个CPU核使用同一个栈运行同一个线程会使得系统立即崩溃。

- 调用switch时，旧线程不应该持有除进程自身锁（注，也就是p->lock）以外的其他锁，因为新线程可能要获取这些锁，如果这些锁被旧线程持有，就会造成死锁。



